# Deploy cluster using ACM

- name: Check if the namespace exists
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Namespace
    name: "{{ cluster.name }}"
  register: namespace_check
  ignore_errors: true

- name: Create namespace if it doesn't exist
  kubernetes.core.k8s:
    name: "{{ cluster.name }}"
    api_version: v1
    kind: Namespace
    state: present
  when: namespace_check.resources | length == 0

- name: Generate the clusterDeployment template
  ansible.builtin.template:
    src: clusterDeployment.yaml.j2
    dest: "{{ deployment_config_dir }}/clusterdeployment.yaml"
    mode: "0644"

- name: Create clusterDeployment resources
  kubernetes.core.k8s:
    state: present
    definition: "{{ lookup('template', 'clusterDeployment.yaml.j2') | from_yaml }}"
  register: cd

# MachinePools are only needed for AWS worker nodes to prevent OpenShift installer from
# automatically substituting instance types (e.g., m6i.xlarge for m5.4xlarge).
# Note: MachinePools can ONLY be used for worker nodes, NOT control plane nodes.
# Control plane nodes are managed directly from install-config and cannot use MachinePools.
# Google and Azure respect the install-config instance types directly.
- name: Generate the worker MachinePool template
  ansible.builtin.template:
    src: machinePool-worker.yaml.j2
    dest: "{{ deployment_config_dir }}/machinepool-worker.yaml"
    mode: "0644"
  when: cloud.provider != 'Google' and cloud.provider != 'Azure'

- name: Create worker MachinePool resource
  kubernetes.core.k8s:
    state: present
    definition: "{{ lookup('template', 'machinePool-worker.yaml.j2') | from_yaml }}"
  when: cloud.provider != 'Google' and cloud.provider != 'Azure'

- name: Wait for adminKubeconfigSecretRef to be populated
  kubernetes.core.k8s_info:
    api_version: hive.openshift.io/v1
    kind: ClusterDeployment
    namespace: "{{ cluster.name }}"
    name: '{{ cluster.name }}'
  register: cd_status
  until:
    - cd_status.resources[0].spec.clusterMetadata.adminKubeconfigSecretRef.name is defined
  retries: 90
  delay: 1

- name: "Wait for Running Pod with label hive.openshift.io/cluster-deployment-name/{{ cluster.name }}"
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Pod
    namespace: "{{ cluster.name }}"
    label_selectors:
      - 'hive.openshift.io/cluster-deployment-name={{ cluster.name }}'
  register: pod_status
  until:
    - pod_status.resources[0].status.phase == 'Running'
  retries: 60
  delay: 5

- name: Get cluster deployment object to find the kubeconfig secret name
  kubernetes.core.k8s_info:
    api_version: hive.openshift.io/v1
    kind: ClusterDeployment
    name: "{{ cluster.name }}"
    namespace: "{{ cluster.name }}"
  register: cluster_deployment

- name: Define the secret name as a fact for later use
  ansible.builtin.set_fact:
    admin_secret_name: "{{ cluster_deployment.resources[0].spec.clusterMetadata.adminKubeconfigSecretRef.name }}"

- name: Get the secret containing the kubeconfig
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Secret
    name: "{{ admin_secret_name }}"
    namespace: "{{ cluster.name }}"
  register: admin_secret_info

- name: Decode and save kubeconfig to file
  ansible.builtin.copy:
    content: "{{ admin_secret_info.resources[0].data.kubeconfig | b64decode }}"
    dest: "{{ deployment_config_dir }}/kubeconfig"
    mode: '0600'

- name: Create managedcluster resource
  kubernetes.core.k8s:
    state: present
    definition: "{{ lookup('template', 'managedCluster.yaml.j2') | from_yaml }}"

- name: Create an import secret using the kubeconfig
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "auto-import-secret"
        namespace: "{{ cluster.name }}"
      type: Opaque
      data:
        kubeconfig: "{{ lookup('file', '{{ deployment_config_dir }}/kubeconfig') | b64encode }}"
  register: auto_import_secret

- name: Create klusterletAddOnConfig
  kubernetes.core.k8s:
    state: present
    definition: "{{ lookup('template', 'klusterletAddOnConfig.yaml.j2') | from_yaml }}"
